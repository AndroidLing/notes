#45. 将局部变量的作用域最小化
将局部变量的作用最小化, 可以增强代码的可读性和可维护性, 并降低出错的可能性

* 要使局部变量的作用域最小化, 最有力的方法就是在第一次使用它的地方声明
* 几乎每个局部变量的声明都应该包含一个初始化表达式, 如果还没有足够的信息来对一个变量进行有意义的初始化, 就应该推迟这个声明, 直到可以初始化为止

#46. for-each循环优先于传统的for循环
利用for-each循环不会有性能损失, 比普通的for循环稍有性能优势, 总之, for-each循环在简洁性和预防Bug方面有着传统的for循环无法比拟的优势, 而且没有性能损失, 应该尽可能地使用for-each循环, 遗憾的是, 有三种常见的情况无法使用for-each循环:

1. 过滤 -- 如果需要遍历集合, 并删除选定的元素, 就需要使用显示的迭代器, 以便可以调用它的remove方法

2. 转换 -- 如果需要遍历列表或者数组, 并取代它部分或者全部的元素值, 就需要列表迭代器或者数组索引, 以便设定元素的值

3. 平行迭代 -- 如果需要并行地遍历多个集合, 就需要显示地控制迭代器或者索引变量, 以便所有迭代器或者索引变量都可以得到同步前移

#47. 了解和使用类库

#48. 如果需要精确的答案, 避免使用float和double
float和double类型主要是为了科学计算和工程计算而设计的, 它们执行二进制浮点运算, 这是为了在广泛的数值范围上提供较为精确的快速近似计算而精心设计的, 然而它们并没有提供完全精确的结果, 所以不应该被用于需要精确结果的场合, float和double类型尤其不合适用于货币计算, 因为要让一个float或者dobule精确地表示0.1(或者10的任何其他负数次方值)是不可能的, 但是可以用BigDecimal、int或者long代替, 然而使用BigDecimal有两个缺点, 一个是与基本运算类型相比, 要麻烦而且慢

总而言之, 对于任何需要精确答案的计算任务, 不要使用float或者double, 如果想让系统来记录十进制小数点, 并且不介意因为不使用基本类型而带来的不便, 可以使用BigDecimal, 使用BigDecimal还有一些额外的好处, 它允许你完全控制舍入, 每当一个操作涉及舍入的时候, 它有8中舍入模式, 如果性能非常关键, 并且又不介意自己记录十进制小数点, 而且所涉及的数值又不太大, 就可以使用int或者long, 如果数值小于9位, 可以使用int, 如果不超过18位, 可以使用long, 否则, 使用BigDecimal

#49. 基本类型优先于装箱基本类型(这个之前说过了)

#50. 如果其他类型更合适, 则尽量避免使用字符串

* 字符串不适合代替其他的值类型: 如果字符串数据本质上确实是文本信息时, 这符合规则, 如果它是数值或者boolean类型, 就应该转换为合适的类型

* 字符串不适合代替枚举类型: 这个前面也提到了, 禁用字符串枚举
 
* 字符串不适合代替聚集类型: 如果一个实体有多个组件, 用一个字符串来表示这个实体是很不恰当的, 当然JSON数据除外, 再说, JSON字符串的目的是方便与数据传输与解析, 本身就是为了解析成具体对象而存在的

#51. 当心字符串连接的性能
字符串连接操作符(+)是把多个字符串合并为一个字符串的便利途径, 要想产生单独行的输出, 或者构造一个字符串来表示一个较小的, 大小固定的对象, 使用连接操作符是非常合适的, 但是它不适合运用在大规模的场景中, 为连接n个字符串而重复地使用字符串连接操作符, 需要n的平方级的时间, 由于字符串不可变而导致的不行结果, 当两个字符串被连接在一起时, 它们的美容都要被copy, 为了获得可以接受的性能, 请使用StringBuilder替代String

#52. 通过接口引用对象
 如果有合适的接口类型存在, 那么对于参数、返回值、变量和域来说, 就都应该使用接口类型进行声明

#53. 接口优先于反射机制
核心反射机制java.lang.reflect, 提供了"通过程序来访问关于已装载的类的信息"的能力, 给定一个Class实例, 可以获得Constructor、Method和Field实例, 分别代表了该Class实例所表示的类的构造器、方法和域, 反射机制允许一个类使用另一个类, 即使当前者被编译的时候后者还根部不存在, 然而, 这种能力也要付出代价:

* 丧失了编译时类型检查的好处: 包括异常检查, 如果程序企图用反射方式调用不存在的或者不能访问的方法, 在运行时它将会失败, 除非采取了特别的预防措施

* 执行反射访问所需要的代码非常笨拙和冗长: 编写这样的代码非常乏味, 阅读起来也很困难

* 性能损失: 反射方法调用比普通方法调用慢了许多

#54. 谨慎地使用本地方法
Java Native Interface(JNI)允许Java应用程序可以调用本地方法, 所谓本地方法是指本地程序设计语言(C或C++)来编写的特殊方法, 本地方法在本地语言中可以执行任意的计算任务, 并返回到Java程序设计语言

* 使用本地方法来提高性能的做法不值得提倡: 如今JVM实现变得越来越快乐, 对于大多数任务, 现在即使不使用本地方法, 也可以获得与之相当的性能

* 本地语言是不安全的: 使用本地方法的应用程序也不再能免受内存毁坏错误的影响, 因为本地语言是与平台相关的, 使用本地方法的应用程序也不再是可自由移植的, 使用本地方法的应用程序也更难调试, 在进入和退出本地代码时, 需要相关的固定开销, 所以本地代码只是做少量工作, 本地方法就可能降低性能

#55. 谨慎地进行优化
优化这东西还是看个人所接触的代码量吧

#56. 遵守普遍接受的命名惯例
每个项目再起始就应该有一套命名规则, 按规则来就好吧